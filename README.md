## Интсрукция по запуску

Чтобы запустить 1 часть проекта, нужно:
1. Скачать его
2. Открыть в редакторе (я писала в WebStorm)
3. Открыть в браузере

Чтобы запустить 2 часть проекта, нужно:
1. Выполнить все указанные пункты выше
2. В консоли ввести: npm run dev

## Ответы на вопросы

### Часть 1

❓ Accessibility 

Для пользователей с нарушениями зрения были применены семантические HTML-теги, обеспечивающие правильную структуру документа, что позволяет скринридерам корректно интерпретировать содержимое страницы. Все интерактивные элементы снабжены текстовыми метками и ARIA-атрибутами, такими как aria-label и aria-required.

Для пользователей с моторными ограничениями реализована полноценная навигация с помощью клавиатуры. Нажимайте "Tab" для перемещения между элементами и "Enter" для активации кнопок. При возникновении ошибок ввода фокус автоматически перемещается на проблемное поле, что упрощает процесс исправления ошибок.

❓ Подход к верстке - Flexbox, базовые элементы реализованы через блочную модель

Данный подход оптимален для форм, где требуется:

1. Абсолютное центрирование (вертикальное центрирования формы в контейнере main, горизонтального распределения кнопок соцсетей, выравнивания чекбокса "Сохранить сессию", построения колоночной структуры страницы) 
2. Линейное расположение элементов
3. Простая адаптация под мобильные устройства - Flexbox-контейнеры с gap и медиазапросами корректно работают на мобильных устройствах

❓ Использование media queries для адаптивной вёрстки, объяснить выбор брейкпоинтов

Выбранные значения соответствуют распространённым стандартам адаптивного дизайна и охватывают основные категории устройств: десктопы (>768px), планшеты (480-768px) и мобильные телефоны (<480px).

Брейкпоинт 768px соответствует переходу от настольных компьютеров к планшетам и небольшим ноутбукам. На этом разрешении начинают применяться изменения: уменьшаются внутренние отступы формы, корректируется максимальная ширина контейнера. Это связано с тем, что на экранах меньше 768px стандартная десктопная компоновка становится избыточной — элементы начинают выглядеть слишком крупными, а горизонтальное пространство используется неэффективно.

Брейкпоинт 480px ориентирован на мобильные устройства. Выбор этого значения обусловлен тем, что 480px — это условная граница между компактными смартфонами и устройствами с более крупными экранами. На этом уровне адаптации происходят более значительные изменения: уменьшаются размеры социальных кнопок, корректируются размеры полей ввода и кнопки входа. Это необходимо потому, что на экранах меньше 480px каждый пиксель становится критически важным для удобства взаимодействия — пальцы пользователя требуют больше места для тапов, а вертикальное пространство ограничено.

❓ Использование js для сохранения введённых данных, их последующего отображения. Почему выбрала localStorage: 

В проекте для сохранения введённых данных используется localStorage, но с важным ограничением — сохраняется только логин, а пароль никогда не сохраняется (такой подход выбран по причинам безопасности).

Пользователь вводит логин и пароль -> при успешном входе и активированном чекбоксе логин (без пароля) сохраняется в localStorage -> при следующем посещении логин автоматически подставляется в поле ввода -> пароль всегда вводится заново

❓ Использование стрелочных и именованных функций

Для основных рабочих функций (createPetals, validateForm, handleSubmit и других) предпочтение отдано именованным функциям. Это обусловлено несколькими ключевыми преимуществами: они обладают поднятием (hoisting), что позволяет располагать вызовы до объявления в коде.

Стрелочные функции применяются для коротких колбэков и анонимных операций — в обработчиках событий (addEventListener), таймерах (setTimeout) и итерациях (forEach). Их главные преимущества здесь: лаконичный синтаксис без излишней структуры.

Лично мне больше импонирует такой гибридный подход. Именованные функции идеальны для сложной бизнес-логики, где важна семантическая ясность и отладка. Стрелочные — для лаконичной работы с асинхронными операциями и коллекциями.

### Часть 2

❓ Почему я выбрала npm?

1. Cтандарт для Node.js: npm поставляется с Node.js, не требует дополнительной установки
3. Достаточность: Для проекта такого масштаба возможностей npm хватает
5. Простота: Более простые команды по сравнению с Yarn
6. Не выбрал pnpm/yarn, потому что их преимущества (скорость, дисковое пространство) критичны для крупных проектов

❓ Конфигурация TypeScript (tsconfig.json)

![2025-06-10_19-54-52](https://github.com/user-attachments/assets/170445ef-32d3-4f73-b653-72c16b56ae47)

1. ES2020 + ESNext - современный стандарт для браузеров
2. Максимальная защита от runtime-ошибок
3. Явное указание типов везде где возможно
4. Оптимальные настройки модулей и совместимость с плагинами Vite (для сборки Vite)
5. Поддержка как TS, так и JS файлов
6. Глобальные типы Jest

❓ Команды serve и build для запуска дев-сервера и сборки проекта

![2025-06-10_19-38-08](https://github.com/user-attachments/assets/00ee0121-28c8-4c52-9a52-7e1c0a7e53d4)

1. Мгновенный запуск: Использует esbuild для ускорения
2. HMR: Горячая перезагрузка без потери состояния
3. Оптимизации: Автоматическое разделение кода, tree-shaking
4. Простота: Минимальная конфигурация для начала работы
5. Поддержка TypeScript: Из коробки

❓ Конфигурация ESLint (линтер)

![2025-06-10_19-43-33](https://github.com/user-attachments/assets/fdc16b41-d812-4a5e-af72-d78cae2a1ed3)

1. Готовые правила: Базовые правила от ESLint и TS-плагина
2. Гибкость: Можно добавлять/отключать правила
3. Автофикс: Поддержка --fix для автоматического исправления
4. TypeScript: Специальный плагин для TS-файлов

❓ Конфигурация Prettier (форматтер) 

![2025-06-10_19-47-56](https://github.com/user-attachments/assets/3739cd5d-76f7-42b5-92be-1797b33f8308)

1. Совместимость с ESLint: Не конфликтует с настройками линтера
2. Читаемость: Оптимальная длина строки (100 символов)
3. Консистентность: Единые кавычки и точки с запятой
4. Современный JS: trailing commas для легкого диффинга

❓ Конфигурация (при подключении фреймворка тестирования)

![2025-06-10_19-51-49](https://github.com/user-attachments/assets/534b4c47-3e92-448f-8688-f373e4a20eeb)

1. Все в одном: Тесты, моки, покрытие кода
2. Speed: Оптимизирован для быстрого выполнения
3. TypeScript: Полная поддержка через ts-jest
4. DOM-тестирование: jsdom для работы с DOM-элементами
5. Популярность: Большое сообщество и документация
